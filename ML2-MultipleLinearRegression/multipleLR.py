# Created by Qixun Qu
# quqixun@gmail.com
# 2017/02/08
# http://quqixun.com/?p=695

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


def read_data(path):
    # This function is used to load data from text file.
    # Retuen feature matrix and label matrix respectively.
    data = pd.read_csv(path, header=None)

    cols = data.shape[1]
    X = data.iloc[:, 0:cols - 1]
    y = data.iloc[:, cols - 1:cols]

    X = np.matrix(X.values)
    y = np.matrix(y.values)

    # Add a column of 1.
    X = np.insert(X, 0, 1, axis=1)

    return X, y


def normalize(X):
    # This function is used to nomalize the input matrix.
    # Method: X_nor = (X - X_mean) / X_std
    X_mean = np.mean(X[:, 1:], 0)
    X_std = np.std(X[:, 1:], 0)

    X_nor = np.ones(X.shape)
    X_nor[:, 1:] = (X[:, 1:] - X_mean) / X_std

    return X_nor, X_mean, X_std


def plot_data(X, y):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(np.array(X[:, 1] / 100), np.array(X[:, 2]), np.array(y / 1000), c='r', marker='o')

    ax.set_xlabel('Area of House in 100 Square Feets')
    ax.set_ylabel('Number of Bed Room')
    ax.set_zlabel('Price in $1000')
    plt.show()


def gradient_descent(X_nor, y, theta, alpha, iteration):
    # Initialize a vector to store all cost values.
    cost_all = np.zeros(iteration)

    for i in range(iteration):
        # Update parameters.
        theta = theta - alpha / len(y) * (X_nor.T * (X_nor * theta - y))
        cost_all[i] = cost_function(X_nor, y, theta)

    return theta, cost_all


def cost_function(X_nor, y, theta):
    # Compute errors between estimate and real values.
    errors = np.power(((X_nor * theta) - y), 2)
    # Calculate cost function value.
    cost = sum(errors) / (2 * len(y))
    return cost


def normal_equation(X, y):
    # Normal Equation:
    # theta = (X' * X)^-1 * X' * y
    theta = np.linalg.inv(X.T * X) * X.T * y
    return theta


def plot_cost(cost_all, iteration):
    # Generate x -coordinate.
    iters = np.arange(0, iteration, 1)

    plt.figure()
    plt.plot(iters, cost_all, lw=2)
    plt.xlabel('Iteration', fontsize=18)
    plt.ylabel('Cost', fontsize=18)
    plt.tick_params(labelsize=15)
    plt.grid(True)
    plt.show()


def plot_result(X, y, theta, mean=0, std=1):
    # Initialize an array to store test instances.
    # Since the result is a plane in 3D space,
    # four points are enough to plot this plane.
    num = 2
    X_test = np.ones((num * num, 3), dtype='float')

    # Generate values for two features.
    X_1 = np.linspace(50, 5000, num)
    X_2 = np.linspace(1, 6, num)
    X_1, X_2 = np.meshgrid(X_1, X_2)

    X_1_r = np.reshape(X_1, (num * num, 1))
    X_2_r = np.reshape(X_2, (num * num, 1))

    np.copyto(X_test[:, 1], X_1_r.T)
    np.copyto(X_test[:, 2], X_2_r.T)

    # Normalize test instances' features as the theta is
    # generated by geadient descent. Features' mean and std
    # should be input in this case.
    # No need to do this when the theta is obatained from
    # Normal equation.
    X_test[:, 1:] = (X_test[:, 1:] - mean) / std

    # Calculate results - prince.
    Z = np.array(X_test * theta)
    Z = np.reshape(Z, (num, num))

    # Plot result.
    fig = plt.figure()
    ax = fig.gca(projection='3d')

    ax.plot_surface(X_1 / 100, X_2, Z / 1000, linewidth=0, alpha=0.3)

    ax.scatter(np.array(X[:, 1]) / 100, np.array(X[:, 2]), np.array(y) / 1000, c='r', marker='o')

    ax.set_xlabel('Area of House in 100 Square Feets')
    ax.set_ylabel('Number of Bed Room')
    ax.set_zlabel('Price in $1000')
    plt.show()


if __name__ == '__main__':
    # Read data form text filt.
    path = os.getcwd() + '/ex1data2.txt'
    X, y = read_data(path)
    plot_data(X, y)

    # Nomalize all features in X.
    # Obtain normalized X as well as X's mean and std.
    X_nor, X_mean, X_std = normalize(X)

    # Set arguments:
    # step size, the number of iteration,
    # initial function parameters.
    alpha = 0.1
    iteration = 50

    theta_num = X.shape[1]
    theta = np.matrix(np.zeros((theta_num, 1)))

    # Implement gradient descent method to
    # estimate function parameters (theta).
    theta, cost_all = gradient_descent(X_nor, y, theta, alpha, iteration)
    # Plot values of cost function w.r.t. iteration.
    plot_cost(cost_all, iteration)
    # Plot result in 3D coordinate with original data.
    plot_result(X, y, theta, X_mean, X_std)

    # Implement normal equation to
    # estimate function parameters (theta_norm).
    theta_norm = normal_equation(X, y)
    # Plot result in 3D coordinate with original data.
    plot_result(X, y, theta_norm)

    # Initialize a test instance.
    sft = 1650  # House area.
    br = 3		# Number of bed room.

    # Test instance estimated by Gradient Descent.
    price = np.array([1, sft, br], dtype='float')
    price[1:] = (price[1:] - X_mean) / X_std
    print("Price estimated by gradient descent:{}".format(np.dot(price, theta)))

    # Test instance estimated by Normal Equation.
    price = np.array([1, sft, br], dtype='float')
    print("Price estimated by normal equation:{}".format(np.dot(price, theta_norm)))
